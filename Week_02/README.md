# 学习笔记

第二周：2020/08/17-2020/08/23

本周感受：一切良好，继续坚持。

第一周学习HashMap，HashSet，二/多叉树，二叉搜索树，堆和图。

关于HashMap：将key通过一个哈希函数，映射到内存空间中的地址，通过访问这个地址，进行数据的直接访问，时间复杂度O(1)。HashMap本质为指针数组，该数组中的每一个元素都是存储数据的链表头指针，再通过遍历链表从而搜索或者插入target val。缺点为如果哈希函数设计的不好，哈希冲突会导致链表很长，从而时间复杂度退化。最差情况为所有key映射到同一个地址，此时为`O(n)`。

关于二叉树和多叉树：大部分为递归操作，递归这块的理解还需要加强，对于困难题目的代码实现还比较欠缺。

关于二叉搜索树：在二叉树的基础上，加入了额外的信息，即左子树小于根节点，右子树大于根节点，以此类推。因为额外信息的注入，树的不确定减少，因此搜索空间随之减小。从而将搜索的时间复杂度从`O(n)`降到`O(logn)`。

关于堆：目前对于堆的理解还比较浮于表面，它是一种优先队列。

关于图：图和树，以及链表之间本质上是相通的。图的唯一区别就是有环，因此遍历时需要标记已访问节点，否则会造成死循环。

# 学习心得

1. 本人学通信出身，转行刚满一年。对于计算机的世界知之甚少。对于提升性能的方法：升维。我找到了数据结构与通信的相似之处。即用信息熵的原理来解释：通过引入额外信息，减少系统的不确定性。对应到数据结构与算法，即引入额外信息，减少算法的搜索空间大小，从而降低了时间复杂度，这种额外信息，可以是题目的信息，也可以是数据结构自身的信息。为什么暴力法效率比较差？因为没有利用到题目信息或者数据结构本身信息，因此搜索空间太大，所以不是最优。

2. 抛弃过去的旧习惯，进行程序员职业化训练，即不会直接看题解，直面自己的无知，不会的题就死记硬背把答案记住，反复过遍数，在过遍数的过程中就会逐渐理解。此谓之『师夷长技以制夷』，借势而起很重要。

3. 关于递归：

   a. 什么时候需要递归的`helper`？

   如果函数的返回值，例如`vector<int>`，每一次递归都需要对它进行修改，即需要将它加入参数列表从而携带进下一次递归。但如果题目所给函数的参数列表中没有这个参数，则需要自行创建`helper`函数。

   b.  drill down 如何理解？

   所谓下探，即一步步向递归终止条件逼近，直到触发递归的反弹（即归），自底向上反推得到最终结果。

4. 劈我战袍，杀上九天

   通过刷题，能够明显的感到自己对代码的掌控力在逐步提高。把基本功打好，内力练好，有朝一日能够做出一些不可能的事。

